### 마치며
- 스벨트 컴포넌트는 HTML요소들로 구성된 쉽고 이해하기 쉬운 문법으로 정의됩니다. script요소는 로직을, style 요소는 CSS 스타일을 정의하며 나머지 HTML요소들로 구성됩니다.
- 컴포넌트에 데이터를 전달할 때 가장 많이 쓰는 방법은 프롭스를 쓰는 것입니다.
- 스벨트 컴포넌트는 다른 컴포넌트를 불러와서 쓸 수 있습니다.
- 스벨트 컴포넌트 안에 정의된 CSS 스타일은 기본적으로 해당 컴포넌트에만 유효합니다.
- 스벨트 컴포넌트의 로직은 자바스크립트 함수들로만 구현됩니다.
- 스벨트 컴포넌트의 최상위 변수들이 컴포넌트의 상태가 됩니다.
- 리액티브 구문은 $:로 시작하며 구문 안에서 참조하는 변숫값이 바뀔

- .svelte 파일은 상태와 로직을 정의하는 자바스크립트 코드, 화면에 그리기 위한 HTML, 그리고 이를 꾸미기 위한 CSS로 이루어져 있습니다.

## .svelte 파일에 담기는 것
- 스벨트 컴포넌트는 클래스나 함수, 객체 리터럴과 같은 자바스크립트 컨테이너로 만들어지지 않습니다. 대신 몇 가지 기본 규칙을 지키는 .svelte 파일로 만들어 집니다. .svelte 파일은 애플리케이션의 src 디렉터리 내에 위치합니다.
- .svelte 파일에는 최대 하나의 `<script context='module'>` 요소와 script 요소 하나, style 요소 하나, body 요소 냐에 하나 이상의 HTML요소를 가질 수 있습니다. 이 요소들 모두가 반드시 있어야 하는 것은 아니며 순서도 자유롭습니다.
- .svelte 파일은 다음과 같은 구조 입니다.
```html
<script>
// 자바스크립트 코드는 여기에 작성합니다.
// 이 코드는 이 컴포넌트에만 영향을 미칩니다.
</script>

<h1>
<!-- 렌터링에 필요한 HTML요소들이 여기에 위치합니다. -->
</h1>

<style>
/**
css 규칙을 여기에 작성합니다.
여기에 작성한 규칙은 이 컴포넌트에서만 유효합니다.
*/
</style>
```
- 각 영역별로 주석을 작성하는 방법이 다릅니다.

## 컴포넌트 마크업
- 스벨트 컴포넌트를 사용하거나 참조하고 화면에 그리는 문법은 HTML 요소의 문법과 같습니다.
- 스벨트 컴포넌트의 인스턴스는 프롭스와 자식들을 전달 받을 수 있습니다. 프롭스로 컴포넌트에 데이터를 전달하고 자식으로 컴포넌트에 콘텐츠를 전달합니다. 그리고 컴포넌트는 언제 자식을 쓸지 결정만 하면 됩니다.
- Person 컴포넌트 예시
~~~html
// Person 컴포넌트 사용 예시
<Person
	fullName='Dohdoh Yang'
	developer={true}
	ball={{name: "baseball", grams: 149, new: false}}
	favoriteColors={['yellow', 'orange']}
	age={calculateAge(person)}
	onBirthday={celebrate}/>

// src/Person.svelte
<script>
	export let age;
	export let ball;
	export let developer;
	export let favoriteColors:
	export let fullName;
	export let onBirthday;
</script>

<div>
	{fullName} is {age} years old and {developer ? 'is' : 'is not'} a developer.
</div>
<div>
	They like the color {favoriteColors.join(' and ')}.
</div>
<div>
	They like to throw {ball.new ? 'a new' : 'an old'} {ball.name} that weight {ball.grams} grams.
</div>
<button on:click={onBirthday}> It's my birthday!</button>
~~~


## 컴포넌트 이름 
- 스벨트 컴포넌트를 정의할 때는 컴포넌트 이름을 명시하지 않습니다. 다른 웹 프레임워크와는 달리 클래스 이름이나 함수 이름, 심지어 컴포넌트 속성들도 컴포넌트 이름과 아무런 연관이 없습니다. 대신 .svelte 파일을 불러오는 경우에만 컴포넌트 이름을 명시합니다. 즉, 불러올 때 지정한 이름이 컴포넌트 이름이 된다는 뜻입니다.
```
// 컴포넌트 호출 및 이름 지정
import Other from './Other.svelte'

// 컴포넌트 선언
<Ohter />
```
- 컴포넌트 이름은 반드시 대문자로 시작해야 하며 여러 단어라면 일반적으로 카멜 표기법을 따릅니다.
- 일반적으로 소스 파일 이름과 컴포넌트 이름을 같게 하는 경우가 많습니다.

## 컴포넌트 스타일
- HTML 요소에 스타일을 추가하는 방법 중 하나는 해당 HTML 요소가 어떤 CSS 규칙을 따를 것인지 class 속성값을 추가하는 거입니다. 여기서 지정하는 css 규칙은 컴포넌트 style 요소 안에 정의되어 있어야 합니다.
```html
<div class:error={status >= 400}>{message}</div>

<div class={status >= 400 ? 'error' : ''}>{message}</div>

// 리액티브 구문을 script 요소에 추가한 경우 아래와 같이 사용이 가능합니다.
// $: error = status >= 400
<div class:error>{message}</div>
```
- 스벨트는 css를 생성할 때 사용하지 않는 css 규칙은 자동으로 제거합니다.

## CSS 명시도
- css 명시도는 css 규칙이 충돌할 때 어떤 규칙을 지정할지를 결정하는 방법입니다.
```html
<div class='parent'>
	I am the parent.
	<div id='me' class='child' style='color: red'>
		I am the child.
	</div>
</div>

<style>
#me { 
	color: orange; /** 점수 : 0,1,0,0 */
}
.parent > .child { 
	color: yellow; /** 점수 : 0,0,2,0 */
} 
.parent .child {
	color: green; /** 점수 : 0,0,2,0 */
} /** 이전 규칙과 점수가 같기 때문에 나중에 나온 규칙이 더 높은 순위를 가집니다. 즉, 나중에 선언된 것이 이전에 선언된 것을 덮어쓴다고 이해할 수 있습니다. */
.child {
	color: blue; /** 점수 : 0,0,1,0 */
}
.parent{
	color: purple /** 점수 : 0,0,1,0 */
} /** 이전 규칙과 점수가 같습니다. 클래스가 'parent'로 지정된 요소에 대해 색을 purple로 지정하지만 이전 규칙의 경우 클래스가 'child'로 지정 된 요소에 대해 색을 blue로 지정합니다. */
</style>
```
- 이 예제에서는 각 규칙의 명시도에 대한 우선순위가 나열된 순서와 같습니다. div 내부에 style속성으로 지정한 것이 가장 높은 명시도를 가집니다.
- css 규칙에 대한 명시도를 네 개의 숫자로 표시할 수 있는 계산 방법이 있습니다. 네 개의 숫자에서 가장 왼쪽이 첫 번째, 가장 오른쪽이 네 번째 숫자라고 하면 다음과 같습니다.
	- 첫번째 숫자는 인라인 스타일인 경우 1, 그렇지 않으면 0입니다.
	- 두번째 숫자는 지정자 안의 id 값입니다.
	- 세번째 숫자는 지정자 안의 클래스 이름 개수 입니다.
	- 네번째 숫자는 지정자 안의 요소 이름에 대한 참조 수 입니다.

## 유효 범위를 가지는 스타일과 전역 스타일
- 전역 스타일은 애플리케이션의 모든 컴포넌트에 똑같이 적용되어야 하는 스타일에 적합합니다.
- 스벨트 컴포넌트 내의 style 요소에 정의한 css 규칙은 자동으로 해당 컴포넌트에 대해서만 유효 범위를 가지며 다른 컴포넌트에 영향을 주지 않습니다. 스타일의 유효 범위는 svelte-hash 형태로 css클래스 이름을 생성하고 적용하는 방식으로 지정됩니다.
- 전역 스타일을 지정하는 방법은 크게 두 가지 입니다.
	- 첫번째 방법은 public/global.css 파일에 스타일을 정의하는 것입니다. 이 파일은 public/index.html 파일이 기본으로 불러오는 스타일의 파일입니다.
	- 두번째 방법은 컴포넌트의 style 요소 안에서 :global (selector)로 스타일을 정의하는 것입니다.

## css 전처리기
- 스벨트 모듈 번들러는 css 전처리기를 쓸 수 있습니다. css 전처리기는 표준 css에서는 지원하지 않는 사용자 정의 스타일 문법을 읽어 와서 표준 css로 바꾸는 일을 합니다.
- 유명한 css 전처리기로는 sass가 있습니다.

## 컴포넌트 로직
- 컴포넌트 로직은 두 가지 방법으로 정의할 수 있습니다.
	- 첫 번째는 script요소 내에 자바스크립트 함수를 정의하는 것입니다.
	- 두 번째는 HTML 요소 내에 블록 구조를 쓰는 것입니다.

## 컴포넌트 상태
- script 요소 내의 가장 상위에 선언되는 변수들 중 HTML 보간에서 참조하는 변수들은 해당 컴포넌트의 상태로 간주됩니다. 이런 상태 변수들의 값을 변경하게 되면 해당 변수를 사용하는 보간들의 표현식이 다시 계산됩니다. 그리고 새로 계산된 값이 이전과 다르면 해당 DOM 부분은 업데이트 됩니다.

## 리액티브 구문
- 자바스크립트 구문 앞에 이름과 콜론(:) 기호를 쓰면, 해당 구문은 레이블 구문이 됩니다. 레이블 구믄은 break나 continue 구문의 목적지가 될 수 있습니다. 하지만 레이블 구문은 일반적으로 거의 사용되지 않습니다.
- 최상위 수준의 구문, 즉 함수 내부나 코드 블록 안에 있지 않는 구문에 레이블을 추가하고 그 레이블의 이름이 달러 기호($) 인 경우, 스벨트는 이 구문을 리액티블 구문으로 간주합니다.
- 자바스크립트는 동일한 유효 범위 내에서 동일한 레이블 이름을 여러 번 쓰는 것을 에러로 간주하지 않습니다.
- 리액티브 구문은 스벨트가 일반적인 자바스크립트 문법을 특별하게 다루는 또 하나의 예시 입니다. 이전에는 리액티브 구문과 비슷하게 export 키워드를 써서 스벨트가 컴포넌트 프롭스를 정의하는 방법을 살펴보기도 했습니다.
- 리액티브 구문은 해당 구문이 참조하는 변수 중 어떤 것이라도 그 값이 바뀌면 다시 실행 됩니다.
```js
// average 변숫값은 처음에 한 번 계산된 뒤, total또는 count 변숫값이 변경되면 다시 계산 됩니다.
$: average = total / count;

// count 변수값은 바뀔 때마다 개발자 도구의 콘솔에 출력됩니다. 이러한 방법을 사용하여 임시로 디버깅 할 수 있습니다.
$: console.log(`count = ${count}`)

// 여러 리액티브 선언문들은 다음과 같은 반응성 블록으로 대체할 수도 있습니다.
let isTeen, upperName;
$: {
	isTeen = 13 <= age && age <20;
	upperName = name.toUpperCase()
}

// $: 구문은 if 구문처럼 여러 구문을 쓸 때에도 적용할 수 있습니다.
// if 구문의 조건문이나 내용에서의 참조하는 변숫값이 바뀌면 다시 실행됩니다.
$: if (someCondition) {
	// 내용
}
```
- 리액티브 선언문은 위상 순서에 따라 실행됩니다. 즉, 리액티브 선언문에서 사용되는 리액티브 선언문의 변수가 먼저 계산됩니다.
- 리액티브 선언문은 실제 실행되는 순서와 동일하게 배치하는 것이 읽기도 편하고 이해하기도 쉽습니다.

## 모듈 컨텍스트
```HTML
<script context="module">
	...
</script>
```
- script 요소에 context를 별도로 명시하지 않으면 인스턴스 콘텍스트 입니다.
- 모듈 컨텍스트에서는 해당 컴포넌트의 모든 인스턴스에서 접근할 수 있는 변수와 함수를 정의 할 수 있습니다. 모든 인스턴스에서 데이터를 공유할 수 있는 것입니다.
- 하지만 모듈 컨텍스트에서 정의하는 변수들은 반응성이 없기 때문에, 이들 변수가 바뀐다고 해서 컴포넌트가 업데이트되지는 않습니다.
- 그리고 모듈 컨텍스트에서는 인스턴스 컨텍스트에 정의된 변수나 함수에 접근할 수 없습니다.

```html
// src/Demo.svelte
<script context='module'>
	export function add(n1, n2) {
		return n1 + n2;
	}
</script>

<script>
	<!-- 컴포넌트의 자바스크립트 코드를 여기에 작성합니다.
</script>

<!-- 컴포넌트의 HTML을 여기에 작성합니다. -->

<style>
	/** 컴포넌트의 CSS를 여기에 작성합니다. */
</style>

// 내보낸 함수 불러와서 사용하기
<script>
	import {onMount} from 'svelte';
	import {add} from './Demo.svelte';

	onMount(() => {
		const sum = add(1, 3);
		console.log(sum = '', sum)
	})
</script>
```
- 위와 같이 쓰는 것도 가능하지만, 이런 유틸리티 함수들을 정의하고 내보내는 것은 .svelte 파일보다 .js 파일을 사용하는 것이 더 일반적입니다.
- 모듈 컨텍스트는 이런 경우보다는 새퍼앱의 컴포넌트가 데이터를 읽어오기 전에 실행하는 preload 함수를 정의할 때 더 많이 사용됩니다.